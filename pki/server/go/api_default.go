/*
 * pki.in GO
 *
 * pki in API docs
 *
 * API version: 1.0.0
 * Contact: paul.goehring@student.uni-tuebingen.de
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */
package swagger

import (
	"crypto"
	"crypto/rand"
	"crypto/rsa"
	"crypto/sha256"
	"crypto/tls"
	"crypto/x509"
	"crypto/x509/pkix"
	"encoding/base64"
	"encoding/hex"
	"encoding/json"
	"encoding/pem"
	"errors"
	"fmt"
	"io"
	"log"
	"math/big"
	mathrand "math/rand"
	"net/http"
	"net/url"
	"os"
	"strconv"
	"time"

	"github.com/golang-jwt/jwt"
)

// path to store the ICT
var PathJWT string = "PKISJWT.jwt"

// path for key business
var PathOwnKey string = "private.key"
var PathRootCrt string = "root.crt"
var PathMarbleRootCrt string = "marblerunCA.crt"
var PathMarbleOwnCrt string = "marbleServerCert.crt"
var PathMarblePrivateKey string = "marbleServer.key"

// serial numbers for issued certificates
var SerialNumber = big.NewInt(0)

// own App Name
var AppName string // os.getEnv("appName")
var OwnPortSecure string
var OwnPortInsecure string

// variables to access root Server to Verify ICT
var RootUrl string
var RootPort string

// variable of next Server to get Certificate
var IpServer string
var PortServerSecure string
var PortServerInsecure string

// everything which is a global variable and can be changed
// should be accesseed via env parameter and can be defined
// in the manifest

// maybe add expire date for challenge
var challenges map[string]ChallengeObject

var challengesRenew map[string]ChallengeObjectRenew

type myJWKClaims struct {
	KeyType   string `json:"kty"`
	Usage     string `json:"use"`
	KeyID     string `json:"kid"`
	Algorithm string `json:"alg"`
	Exponent  string `json:"e"`
	Modulus   string `json:"n"`
}

type KeyResponse struct {
	Keys []PublicKeyInfo `json:"keys"`
}

type ChallengeObject struct {
	ID         string
	NonceToken string
}

type ChallengeObjectRenew struct {
	ID               string
	NonceTokenOldKey string
	NonceTokenNewKey string
}

type PublicKeyInfo struct {
	E   string    `json:"e"`
	Kid string    `json:"kid"`
	N   string    `json:"n"`
	Use string    `json:"use"`
	Kty string    `json:"kty"`
	Alg string    `json:"alg"`
	Exp time.Time `json:"exp"`
}

func Initialize() {
	AppName = "PKI Intermediate Server" + fmt.Sprint(mathrand.Intn(1000))

	err := os.WriteFile(PathMarbleRootCrt, []byte(os.Getenv("MARBLE_ROOT_CA")), 0644)
	if err != nil {
		fmt.Println("Error Writing Marble Root Certificate", err)
	}

	err = os.WriteFile(PathMarbleOwnCrt, []byte(os.Getenv("MARBLE_CERT")), 0644)
	if err != nil {
		fmt.Println("Error Writing Marble Own Certificate", err)
	}

	err = os.WriteFile(PathMarblePrivateKey, []byte(os.Getenv("MARBLE_KEY")), 0644)
	if err != nil {
		fmt.Println("Error Writing Marble Private Key", err)
	}

	OwnPortSecure = os.Getenv("OWN_PORT_SECURE")
	OwnPortInsecure = os.Getenv("OWN_PORT_INSECURE")

	// variables to access root Server to Verify ICT
	RootUrl = os.Getenv("ROOT_URL")
	RootPort = os.Getenv("ROOT_PORT")

	// variable of next Server to get Certificate
	IpServer = os.Getenv("SERVER_IP")
	PortServerSecure = os.Getenv("SERVER_PORT_SECURE")
	PortServerInsecure = os.Getenv("SERVER_PORT_INSECURE")
	// create key pair
	CreateKeyPair(PathOwnKey)
	challenges = make(map[string]ChallengeObject)
	challengesRenew = make(map[string]ChallengeObjectRenew)

	// get certificate from root pkis
	// same as in client
	GetCertificate(PathOwnKey, PathJWT, AppName, IpServer, PortServerSecure)
	// check if Cert expires, before renew cert

	// for testing purposes
	time.Sleep(5 * time.Second)

	RenewCertificate(IpServer, PortServerInsecure, PathJWT, PathOwnKey, AppName, false)

	go checkTokenExpirationPeriodically(PathJWT)

}

func checkTokenExpirationPeriodically(jwtFilePath string) {
	// checks if the JWT is about to expire and renews it if necessary
	for {
		// Read the JWT from the file
		jwtBytes, err := os.ReadFile(jwtFilePath)
		if err != nil {
			fmt.Println("Error reading JWT file:", err)
			return
		}

		// Parse the JWT token
		token, _, err := new(jwt.Parser).ParseUnverified(string(jwtBytes), jwt.MapClaims{})
		if err != nil {
			fmt.Println("Error parsing JWT:", err)
			return
		}

		// Extract the expiration time from the token claims
		expirationTime := time.Unix(int64(token.Claims.(jwt.MapClaims)["exp"].(float64)), 0)

		// Calculate the exact wait time until 5 minutes before expiration
		timeToWait := time.Until(expirationTime.Add(-5 * time.Minute))

		// Check if the token will expire within 5 minutes
		if timeToWait > 0 {
			// Wait until 5 minutes before expiration
			fmt.Printf("Waiting until %v before renewing certificate...\n", timeToWait)
			time.Sleep(timeToWait)

			// Call the RenewCertificate function
			RenewCertificate(IpServer, PortServerInsecure, PathJWT, PathOwnKey, AppName, false)
		}

		// Sleep for a short duration before checking expiration again
		time.Sleep(1 * time.Minute)
	}
}

func GetChallengeGet(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodGet {
		http.Error(w, "No valid Method", http.StatusMethodNotAllowed)
		return
	}
	fmt.Println("Received Challenge Token")

	frontendAppID := r.URL.Query().Get("appID")

	nonce := GenerateNonce()
	if frontendAppID != "" {
		newRequest := ChallengeObject{
			ID: frontendAppID,
			//ID:         backendAppID,
			NonceToken: nonce,
		}
		//fmt.Println(newRequest.ID, newRequest.URL, newRequest.NonceToken)
		challenges[frontendAppID] = newRequest
	} else {
		fmt.Println("value for AppID missing")
		nonce = "Value for AppID missing"
	}

	w.Header().Set("Content-Type", "text/plain")
	fmt.Fprint(w, nonce)
}

func GetNewChallengeGet(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodGet {
		http.Error(w, "No valid Method", http.StatusMethodNotAllowed)
		return
	}
	fmt.Println("Received Challenge Request")

	frontendAppID := r.URL.Query().Get("appID")

	nonce1 := GenerateNonce()

	if frontendAppID != "" {
		newRequest := ChallengeObjectRenew{
			ID:               frontendAppID,
			NonceTokenNewKey: nonce1,
		}

		challengesRenew[frontendAppID] = newRequest

		// Respond with a JSON containing both nonces
		response := map[string]string{
			"nonceNewKey": nonce1,
		}

		responseJSON, err := json.Marshal(response)
		if err != nil {
			http.Error(w, "Error encoding JSON response", http.StatusInternalServerError)
			return
		}

		w.Header().Set("Content-Type", "application/json")
		w.Write(responseJSON)
		return
	}

	fmt.Println("value for AppID missing")
	nonce := "Value for AppID missing"

	w.Header().Set("Content-Type", "text/plain")
	fmt.Fprint(w, nonce)
}

func GetTokenGet(w http.ResponseWriter, r *http.Request) {
	// wrap in correct tls method, check for root stuff
	if r.Method != http.MethodGet {
		http.Error(w, "No valid Method", http.StatusMethodNotAllowed)
		return
	}
	fmt.Println("Got Certification request")
	tokenString := r.Header.Get("Authorization")[7:]

	parsedToken, _ := jwt.Parse(tokenString, nil)
	privateKey, err := LoadPrivateKeyFromFile(PathOwnKey)
	if err != nil {
		fmt.Println("Error loading private key", err)
	}

	claims, ok := parsedToken.Claims.(jwt.MapClaims)
	if !ok {
		// handle invalid claims ?
		fmt.Println("Invalid JWT claims")
		return
	}

	publicKeyData := claims["jwk"].(map[string]interface{})
	n1, _ := publicKeyData["n"].(string)
	e1, _ := publicKeyData["e"].(string)

	n2 := new(big.Int)
	n2.SetString(n1, 10)

	e2 := new(big.Int)
	e2.SetString(e1, 10)

	recreatePubKey := &rsa.PublicKey{
		N: n2,
		E: int(e2.Int64()),
	}
	//publicKeyPEM22 := &pem.Block{
	//	Type:  "RSA PUBLIC KEY",
	//	Bytes: x509.MarshalPKCS1PublicKey(recreatePubKey),
	//}
	//fmt.Println("\nPublic Key in PEM Format:")
	//publicKeyString := string(pem.EncodeToMemory(publicKeyPEM22))
	//fmt.Println(publicKeyString)

	//modulus := new(big.Int)
	//modulus.SetString(publicKeyJSON.n, 10)

	//frontendAppID := r.URL.Query().Get("appID")
	signedFingerprint := claims["fingerprint"].(string)
	frontendAppID := claims["sub"].(string)

	fingerprintToVerify := challenges[frontendAppID].NonceToken + challenges[frontendAppID].ID

	// here check if nonce + appID correct, every nonce needs a number for map i guess, after delete from data structure
	ver, err := VerifySignature(fingerprintToVerify, signedFingerprint, recreatePubKey)
	if ver {
		fmt.Println("Verification successfull")
	} else {
		fmt.Println("Unsuccessfull", err)
		w.WriteHeader(http.StatusUnauthorized)
		message := "Access Denied: You do not have permission to access this resource."
		fmt.Fprintln(w, message)
		return
	}

	newJwt := CreateJwt(privateKey, frontendAppID, recreatePubKey, frontendAppID, RootUrl, RootPort)

	w.Header().Set("Content-Type", "application/json")
	fmt.Fprint(w, newJwt)

	// Now give back jwt signed by server as response, validate at rpki endpoint at the end
}

func CreateCert(SerialNumber *big.Int, pubKey *rsa.PublicKey, signingCertPath string,
	signingKeyPath string, issuedName string, validHours int, certType string) []byte {

	certTemplate := Generatex509Template(SerialNumber, issuedName, validHours, certType)
	var signingCert *x509.Certificate
	var certDER []byte
	signingKey, err := LoadPrivateKeyFromFile(signingKeyPath)
	if err != nil {
		fmt.Println("Error loading Private Key")
	}
	if signingCertPath != "" {
		signingCertPEM, err := os.ReadFile(signingCertPath)
		if err != nil {
			fmt.Println("Error loading signing Certificate")
		}
		signingCert, err = parseCertificatePEM(signingCertPEM)
		if err != nil {
			fmt.Println("Error parsing signing Certificate PEM", err)
		}
		certDER, err = x509.CreateCertificate(rand.Reader, &certTemplate, signingCert,
			pubKey, signingKey)
		if err != nil {
			fmt.Println("Error creating Certificate", err)
		}
	} else {
		certDER, err = x509.CreateCertificate(rand.Reader, &certTemplate, &certTemplate,
			pubKey, signingKey)
		if err != nil {
			fmt.Println("Error creating Certificate", err)
		}
	}

	SerialNumber.Add(SerialNumber, big.NewInt(1))
	return pem.EncodeToMemory(&pem.Block{Type: "CERTIFICATE", Bytes: certDER})
}

func parseCertificatePEM(certPEM []byte) (*x509.Certificate, error) {
	block, _ := pem.Decode(certPEM)
	if block == nil || block.Type != "CERTIFICATE" {
		return nil, fmt.Errorf("failed to decode PEM block containing certificate")
	}

	cert, err := x509.ParseCertificate(block.Bytes)
	if err != nil {
		return nil, fmt.Errorf("error parsing certificate: %v", err)
	}

	return cert, nil
}

func Generatex509Template(serialNumber *big.Int, subjectName string, validHours int, certType string) x509.Certificate {
	if certType == "root" {
		certTemplate := x509.Certificate{
			SerialNumber: serialNumber,
			Subject:      pkix.Name{Organization: []string{subjectName}},
			NotBefore:    time.Now(),
			NotAfter:     time.Now().Add(time.Duration(validHours) * time.Hour), // Valid for 10 years

			// do i need key usage fields ?
			KeyUsage:    x509.KeyUsageKeyEncipherment | x509.KeyUsageDigitalSignature | x509.KeyUsageCertSign,
			ExtKeyUsage: []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth, x509.ExtKeyUsageClientAuth},
			IsCA:        true,
		}
		return certTemplate
	} else if certType == "intermediate" {
		certTemplate := x509.Certificate{
			SerialNumber: serialNumber,
			Subject:      pkix.Name{Organization: []string{subjectName}},
			NotBefore:    time.Now(),
			NotAfter:     time.Now().Add(time.Duration(validHours) * time.Hour), // Valid for 10 years

			// do i need key usage fields ?
			KeyUsage:    x509.KeyUsageKeyEncipherment | x509.KeyUsageDigitalSignature | x509.KeyUsageCertSign,
			ExtKeyUsage: []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth, x509.ExtKeyUsageClientAuth},
			//IsCA:        isCA,
		}
		return certTemplate
	} else {
		certTemplate := x509.Certificate{
			SerialNumber: serialNumber,
			Subject:      pkix.Name{Organization: []string{subjectName}},
			NotBefore:    time.Now(),
			NotAfter:     time.Now().Add(time.Duration(validHours) * time.Hour), // Valid for 10 years
		}
		return certTemplate
	}
}

func GetCertificate(keyPath string, tokenPath string, appId string, serverIp string, serverPort string) {
	// placeholder

	nonceToken := GetChallenge(serverIp, serverPort, appId)
	challenge := string(nonceToken)

	fmt.Println("Requesting Workload Identity Token")

	fingerprint := challenge + appId
	privateKey, err := LoadPrivateKeyFromFile(keyPath)
	if err != nil {
		fmt.Println("Error loading private key", err)
	}

	signedToken, err := SignToken(fingerprint, privateKey)
	if err != nil {
		fmt.Println("Error signing token", err)
	}

	newJwt, err := ClientCreateJwt(privateKey, signedToken, appId)
	if err != nil {
		fmt.Println("Error creating JWT token", err)
	}
	//fmt.Println(newJwt)

	client := &http.Client{
		Transport: &http.Transport{
			TLSClientConfig: DefineClientTLSConfig2(),
		},
	}
	url := fmt.Sprintf("https://%v:%v/getCert", serverIp, serverPort)
	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		fmt.Println("Error creating request", err)
	}
	req.Header.Set("Authorization", "Bearer "+newJwt)

	resp, err := client.Do(req)
	if err != nil {
		fmt.Println("Error sending request", err)
		return
	}
	defer resp.Body.Close()
	body, err := io.ReadAll(resp.Body)
	if err != nil {
		fmt.Println("Error reading response", err)
		return
	}

	err = os.WriteFile(tokenPath, body, 0644)
	if err != nil {
		fmt.Println("Error Writing JWT", err)
	}

	fmt.Println("Successfuly Received Workload Identity Token")

}

var response struct {
	JWT string `json:"jwt"`
}

func VerifySignature(token, signature string, publicKey *rsa.PublicKey) (bool, error) {
	decodedSignature, err := base64.StdEncoding.DecodeString(signature)
	if err != nil {
		return false, err
	}

	hashed := sha256.Sum256([]byte(token))
	err = rsa.VerifyPKCS1v15(publicKey, crypto.SHA256, hashed[:], decodedSignature)
	if err != nil {
		return false, nil // Verification failed
	}
	//fmt.Println(token, signature, decodedSignature, hashed)
	return true, nil // Verification successful
}

func GenerateKIDFromPublicKey(publicKey *rsa.PublicKey) string {
	hash := sha256.Sum256(publicKey.N.Bytes())
	kid := hex.EncodeToString(hash[:])
	return kid
}

func CreateJwt(privKey *rsa.PrivateKey, frontEndID string, publicKey *rsa.PublicKey, appID string, rootIp string, rootPort string) string {
	//x5cField := append([]string{issuedCert}, certChain...)

	iat := time.Now()
	expiration := iat.Add(time.Hour * 1)
	myClaims := myJWKClaims{
		KeyType:   "RSA",
		Usage:     "sig",
		KeyID:     GenerateKIDFromPublicKey(publicKey), // here maybe hash of the key idk how this works
		Algorithm: "RS256",
		Exponent:  strconv.Itoa(publicKey.E),
		Modulus:   publicKey.N.String(),
	}
	claims := jwt.MapClaims{
		"sub": frontEndID,
		"iss": fmt.Sprintf("http://%v:%v", rootIp, rootPort),
		"iat": iat.Unix(),        // maybe without Unix?
		"exp": expiration.Unix(), // maybe without unix
		"jwk": myClaims,
	}
	header := jwt.MapClaims{
		"alg": "RS256",
		"kid": GenerateKIDFromPublicKey(&privKey.PublicKey),
		"typ": "JWT",
	}

	token := jwt.NewWithClaims(jwt.SigningMethodRS256, claims)
	token.Header = header
	tokenString, err := token.SignedString(privKey)
	if err != nil {
		return ""
	}
	return tokenString
}

func GenerateNonce() string {
	// TODO check if in nonce map
	nonceBytes := make([]byte, 32)
	_, err := rand.Read(nonceBytes)
	if err != nil {
		fmt.Println("Nonce could not be generated", err)
	}
	nonce := base64.StdEncoding.EncodeToString(nonceBytes)
	//fmt.Println(nonce)
	return nonce
}

func LoadPrivateKeyFromFile(filename string) (*rsa.PrivateKey, error) {
	keyFile, err := os.ReadFile(filename)
	if err != nil {
		return nil, err
	}

	block, _ := pem.Decode(keyFile)
	if block == nil || block.Type != "RSA PRIVATE KEY" {
		return nil, fmt.Errorf("invalid private key format")
	}

	return x509.ParsePKCS1PrivateKey(block.Bytes)
}

func CreateKeyPair(keyPath string) {
	// create and store key Pair
	privateKey, err := rsa.GenerateKey(rand.Reader, 2048)
	if err != nil {
		fmt.Println("Key pair could not get generated", err)
		return
	}

	// TODO: store private key securely
	privateKeyPem := &pem.Block{Type: "RSA PRIVATE KEY", Bytes: x509.MarshalPKCS1PrivateKey(privateKey)}
	err = os.WriteFile(keyPath, pem.EncodeToMemory(privateKeyPem), 0644)
	if err != nil {
		fmt.Println("Private key could not get stored", err)
		return
	}
	publicKey := &privateKey.PublicKey
	publicKeyPem := &pem.Block{Type: "RSA PUBLIC KEY", Bytes: x509.MarshalPKCS1PublicKey(publicKey)}
	err = os.WriteFile("public.key", pem.EncodeToMemory(publicKeyPem), 0644)
	if err != nil {
		fmt.Println("Public key could not get stored", err)
	}

}

func ClientCreateJwt(privKey *rsa.PrivateKey, fingerprint string, frontEndID string) (string, error) {
	myClaims := myJWKClaims{
		KeyType:   "RSA",
		Usage:     "sig",
		KeyID:     GenerateKIDFromPublicKey(&privKey.PublicKey),
		Algorithm: "RS256",
		Exponent:  strconv.Itoa(privKey.PublicKey.E),
		Modulus:   privKey.PublicKey.N.String(),
	}
	claims := jwt.MapClaims{
		"sub":         frontEndID,
		"iss":         "client",
		"fingerprint": fingerprint,
		"exp":         time.Now().Add(time.Hour * 1).Unix(),
		"jwk":         myClaims,
	}
	token := jwt.NewWithClaims(jwt.SigningMethodRS256, claims)
	tokenString, err := token.SignedString(privKey)
	if err != nil {
		return "", err
	}
	return tokenString, nil
}

func SignToken(token string, privateKey *rsa.PrivateKey) (string, error) {
	hashed := sha256.Sum256([]byte(token))
	result, err := rsa.SignPKCS1v15(rand.Reader, privateKey, crypto.SHA256, hashed[:])
	if err != nil {
		return "Could not sign Token", err
	}
	encodedResult := base64.StdEncoding.EncodeToString(result)
	return encodedResult, nil

}

func GetChallenge(challengeIp string, challengePort string, appId string) []byte {
	client := http.Client{
		Transport: &http.Transport{
			TLSClientConfig: DefineClientTLSConfig2(),
		},
	}
	u, err := url.Parse(fmt.Sprintf("https://%s:%s/getChallenge", challengeIp, challengePort))
	if err != nil {
		log.Fatal(err)
	}
	q := u.Query()
	q.Set("appID", appId)
	u.RawQuery = q.Encode()

	request1, err := client.Get(u.String())
	if err != nil {
		fmt.Println("Could not reach Server", err)
		return nil
	}
	defer request1.Body.Close()

	nonceToken, err := io.ReadAll(request1.Body)
	if err != nil {
		fmt.Println("Error reading Nonce Response", err)
	}
	fmt.Println("Received Challenge Token")
	return nonceToken
}

func DefineTLSConfig() *tls.Config {
	// defines Server TLS Config for secure intial connection
	var tlsConfig *tls.Config

	ownCert, err := tls.LoadX509KeyPair(PathMarbleOwnCrt, PathMarblePrivateKey)
	if err != nil {
		fmt.Println("Error Loading Server cert", err)
		return nil
	}

	marbleCert, err := os.ReadFile(PathMarbleRootCrt)
	if err != nil {
		fmt.Println("Error loading marble root certificate:", err)
		return nil
	}

	certPool := x509.NewCertPool()
	certPool.AppendCertsFromPEM(marbleCert)

	tlsConfig = &tls.Config{
		Certificates: []tls.Certificate{ownCert},
		ClientAuth:   tls.RequireAndVerifyClientCert,
		ClientCAs:    certPool,
		VerifyPeerCertificate: func(rawCerts [][]byte, verifiedChains [][]*x509.Certificate) error {
			// Check if there are any verified chains
			if len(verifiedChains) == 0 {
				return fmt.Errorf("no verified chains found")
			}

			// Extract the leaf certificate from the first chain
			leafCert := verifiedChains[0][0]

			// Check if the "NotBefore" field of the leaf certificate is not older than 5 minutes ago
			iat := leafCert.NotBefore
			maxAge := 5 * time.Minute // Change to 5 later
			if time.Since(iat) > maxAge {
				return fmt.Errorf("client certificate is too old (issued more than 5 minutes ago)")
			}

			return nil
		},
	}
	return tlsConfig

}

func DefineClientTLSConfig2() *tls.Config {
	// defines Client TLS Config for secure intial connection
	var tlsConfig *tls.Config

	ownCert, err := tls.LoadX509KeyPair(PathMarbleOwnCrt, PathMarblePrivateKey)
	if err != nil {
		fmt.Println("Error Loading Server cert", err)
		return nil
	}

	tlsConfig = &tls.Config{
		Certificates:       []tls.Certificate{ownCert},
		InsecureSkipVerify: true,
	}

	return tlsConfig

}

func GetNewTokenGet(w http.ResponseWriter, r *http.Request) {

	if r.Method != http.MethodGet {
		http.Error(w, "No valid Method", http.StatusMethodNotAllowed)
		return
	}
	fmt.Println("Got Certification request")

	tokenString := r.Header.Get("Authorization")[7:]

	parsedToken, _ := jwt.Parse(tokenString, nil)

	privateKey, err := LoadPrivateKeyFromFile(PathOwnKey)

	claims, ok := parsedToken.Claims.(jwt.MapClaims)
	if !ok {
		fmt.Println("Invalid JWT claims")
		return
	}

	oldIct, ok := claims["ict"].(string)
	if !ok {
		http.Error(w, "No ict found in request", http.StatusUnauthorized)
		return
	}

	if !VerifyICT(RootUrl, RootPort, oldIct) {
		fmt.Println("Unsuccessfull", err)
		w.WriteHeader(http.StatusUnauthorized)
		message := "Access Denied: You do not have permission to access this resource."
		fmt.Fprintln(w, message)
		return
	}

	parsedIct, _ := jwt.Parse(oldIct, nil)

	ictClaims, ok := parsedIct.Claims.(jwt.MapClaims)
	if !ok {
		fmt.Println("Invalid JWT claims")
		return
	}

	oldPublicKeyData := ictClaims["jwk"].(map[string]interface{})
	n1, _ := oldPublicKeyData["n"].(string)
	e1, _ := oldPublicKeyData["e"].(string)

	n2 := new(big.Int)
	n2.SetString(n1, 10)

	e2 := new(big.Int)
	e2.SetString(e1, 10)

	recreateOldPubKey := &rsa.PublicKey{
		N: n2,
		E: int(e2.Int64()),
	}

	newPublicKeyData := claims["jwk"].(map[string]interface{})
	n11, _ := newPublicKeyData["n"].(string)
	e11, _ := newPublicKeyData["e"].(string)
	n22 := new(big.Int)
	n22.SetString(n11, 10)

	e22 := new(big.Int)
	e22.SetString(e11, 10)

	recreateNewPubKey := &rsa.PublicKey{
		N: n22,
		E: int(e22.Int64()),
	}

	signedNewFingerprint := claims["fingerprintnewkey"].(string)
	frontendAppID := claims["sub"].(string)

	newFingerprintToVerify := challengesRenew[frontendAppID].NonceTokenNewKey + challenges[frontendAppID].ID

	tokenValid, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {
		return recreateOldPubKey, nil
	})
	if err == nil && tokenValid.Valid {
		fmt.Println("JWT is valid.")
	} else {
		fmt.Println("Unsuccessfull", err)
		w.WriteHeader(http.StatusUnauthorized)
		message := "Access Denied: You do not have permission to access this resource."
		fmt.Fprintln(w, message)
		return
	}

	ver, err := VerifySignature(newFingerprintToVerify, signedNewFingerprint, recreateNewPubKey)
	if ver {
		fmt.Println("Verification of new Key successfull")
	} else {
		fmt.Println("Unsuccessfull", err)
		w.WriteHeader(http.StatusUnauthorized)
		message := "Access Denied: You do not have permission to access this resource."
		fmt.Fprintln(w, message)
		return
	}

	newJwt := CreateJwt(privateKey, frontendAppID, recreateNewPubKey, frontendAppID, RootUrl, RootPort)

	w.Header().Set("Content-Type", "application/json")
	fmt.Fprint(w, newJwt)

}

func RenewCertificate(serverIp string, serverPort string, pathJwt string, pathKey string, appID string, newKey bool) {
	// get new challenge
	// if new key then you need two proof of possession
	// formulate new jwt, including old jwt

	nonce := GetNewChallenge(serverIp, serverPort, appID)

	fmt.Println("Requesting New Workload Identity Token")

	oldICT, err := os.ReadFile(pathJwt)
	if err != nil {
		fmt.Println("Error reading JWT file:", err)
		return
	}

	fingerprintNew := string(nonce) + appID
	privateKeyOld, err := LoadPrivateKeyFromFile(pathKey)
	if err != nil {
		fmt.Println("Error loading private key", err)
	}

	var privateKeyNew *rsa.PrivateKey
	if newKey {
		// create new key pair
		CreateKeyPair(pathKey)
		privateKeyNew, err = LoadPrivateKeyFromFile(pathKey)
		if err != nil {
			fmt.Println("Error loading private key", err)
		}
	} else {
		privateKeyNew = privateKeyOld
	}

	signedTokenNew, err := SignToken(fingerprintNew, privateKeyNew)
	if err != nil {
		fmt.Println("Error signing new token", err)
	}

	// sign Jwt with old Key to make proof of possession
	newJwt, err := createNewJwt(oldICT, privateKeyOld, signedTokenNew, appID)
	if err != nil {
		fmt.Println("Error creating JWT token", err)
	}

	client := &http.Client{
		Transport: &http.Transport{},
	}
	//fmt.Println(newJwt)
	serverUrl := fmt.Sprintf("http://%v:%v/getNewCert", serverIp, serverPort)
	req, err := http.NewRequest("GET", serverUrl, nil)
	if err != nil {
		fmt.Println("Error creating request", err)
	}

	req.Header.Set("Authorization", "Bearer "+newJwt)

	resp, err := client.Do(req)
	if err != nil {
		fmt.Println("Error sending request", err)
		return
	}
	defer resp.Body.Close()
	body, err := io.ReadAll(resp.Body)
	if err != nil {
		fmt.Println("Error reading response", err)
		return
	}

	err = os.WriteFile(pathJwt, body, 0644)
	if err != nil {
		fmt.Println("JWT could not be stored", err)
	}

	fmt.Println("Successfuly Received new Workload Identity Token")
}

func GetNewChallenge(serverIp string, serverPort string, appID string) string {

	u, err := url.Parse(fmt.Sprintf("http://%s:%s/getNewChallenge", serverIp, serverPort))
	if err != nil {
		fmt.Println("Could not parse URL", err)
		return ""
	}
	q := u.Query()
	q.Set("appID", appID)
	u.RawQuery = q.Encode()

	request1, err := http.Get(u.String())
	if err != nil {
		fmt.Println("Could not reach Server", err)
		return ""
	}
	defer request1.Body.Close()
	fmt.Println("Received Challenge Token")

	var data map[string]string
	err = json.NewDecoder(request1.Body).Decode(&data)
	if err != nil {
		fmt.Println("Error decoding JSON response:", err)
		return ""
	}
	nonceNewKey := data["nonceNewKey"]
	return nonceNewKey
}

func createNewJwt(oldICT []byte, privKey *rsa.PrivateKey, fingerprintNew string,
	frontEndID string) (string, error) {
	myClaims := myJWKClaims{
		KeyType:   "RSA",
		Usage:     "sig",
		KeyID:     GenerateKIDFromPublicKey(&privKey.PublicKey),
		Algorithm: "RS256",
		Exponent:  strconv.Itoa(privKey.PublicKey.E),
		Modulus:   privKey.PublicKey.N.String(),
	}
	claims := jwt.MapClaims{
		"sub":               frontEndID,
		"iss":               frontEndID,
		"fingerprintnewkey": fingerprintNew,
		"exp":               time.Now().Add(time.Hour * 1).Unix(),
		"jwk":               myClaims,
		"ict":               string(oldICT),
	}
	token := jwt.NewWithClaims(jwt.SigningMethodRS256, claims)
	tokenString, err := token.SignedString(privKey)
	if err != nil {
		return "", err
	}
	return tokenString, nil
}

func VerifyICT(rootIp string, rootPort string, tokenString string) bool {

	token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {
		resp, err := http.Get(fmt.Sprintf("http://%v:%v/.well-known/certs", rootIp, rootPort))
		if err != nil {
			return nil, err
		}
		defer resp.Body.Close()

		body, err := io.ReadAll(resp.Body)
		if err != nil {
			return nil, err
		}

		var jwks = KeyResponse{}
		err = json.Unmarshal(body, &jwks)
		if err != nil {
			return nil, err
		}

		kid, ok := token.Header["kid"].(string)
		if !ok {
			return nil, errors.New("kid field is missing from token or is not a string")
		}

		var publicKeyKid PublicKeyInfo

		keyFound := false
		for _, key := range jwks.Keys {
			if key.Kid == kid {
				publicKeyKid = key
				keyFound = true
				break
			}
		}
		if !keyFound {
			return nil, errors.New("unable to find appropriate key")
		}

		n := new(big.Int)
		n.SetString(publicKeyKid.N, 10)
		e := new(big.Int)
		e.SetString(publicKeyKid.E, 10)
		recreatePubKey := &rsa.PublicKey{
			N: n,
			E: int(e.Int64()),
		}
		return recreatePubKey, nil
	})

	if err != nil {
		fmt.Println("Error while parsing token: ", err)
		return false
	}

	if _, ok := token.Claims.(jwt.MapClaims); ok && token.Valid {
		fmt.Println("Token is valid.")
		return true
	} else {
		fmt.Println("Invalid token")
		return false
	}
}
